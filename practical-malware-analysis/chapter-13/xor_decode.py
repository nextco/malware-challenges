# Python 3.7 x64 Windows
# by @rextco
def read_file(file_name):
    with open(file_name, "rb") as fp:
        c = fp.read()
    return c


def write_file(file_name, content):
    with open(file_name, "wb") as f:
        f.write(content)


def single_byte_key_xor(plaintext, key):
    if (key < 0x0) or (key > 0xFF):
        raise Exception("!single_byte_key_xor key bad range")

    ciphertext_bytes = bytearray()
    plaintext_bytes = bytearray(plaintext)

    # XOR every byte of the plaintext
    for i in range(len(plaintext)):
        ciphertext_bytes.append(plaintext_bytes[i] ^ key)

    return ciphertext_bytes


def single_preserving_byte_key_xor(plaintext, key):
    if (key < 0x0) or (key > 0xFF):
        raise Exception("!single_byte_key_xor key bad range")

    ciphertext_bytes = bytearray()
    plaintext_bytes = bytearray(plaintext)

    # XOR every byte of the plaintext
    for i in range(len(plaintext)):
        if (plaintext_bytes[i] == 0x0) or (plaintext_bytes[i] == key):
            ciphertext_bytes.append(plaintext_bytes[i])
        else:
            ciphertext_bytes.append(plaintext_bytes[i] ^ key)

    return ciphertext_bytes


def repeating_key_xor(plaintext, key):
    if len(key) == 0 or len(key) > len(plaintext):
        raise Exception("!repeating_key_xor key size if bigger than the plain text")

    ciphertext_bytes = bytearray()
    plaintext_bytes = bytearray(plaintext, encoding="utf-8")
    key_bytes = bytearray(key, encoding="utf-8")

    # XOR every byte of the plaintext with the corresponding byte from the key
    for i in range(len(plaintext)):
        k_ = key_bytes[i % len(key)]
        c_ = plaintext_bytes[i] ^ k_
        ciphertext_bytes.append(c_)

    return ciphertext_bytes


def bruteforce_seeking(string):
    # Offset |size(bytes) |   crypted  |  unencrypted
    # 0000h  |     2      |    242c    |  424d  (BM)
    # 0002h  |     4      |  9ae3626e  |  F68F0700 (*) | Tamano del archivo en bytes ls -l ch3.data
    # 0006h  |     2      |    6661    |  0000  (usually not used -> 00 00)
    # 0008h  |     2      |    6c6c    |  0000  (usually not used -> 00 00)
    # 000Ah  |     4      |  536e6661  |  36000000 (very common offset with the 0x28 bytes long DIB header)
    # (*) the size of the image is unchanged with xor and is: 0x00078FF6 > litle endian 0xf6 8f 07 00

    # Se comienza con cada byte y se va buscando manualmente
    key_base = chr(0x66) + chr(0x61) + chr(0x6c) + chr(0x6c) + chr(0x65) + chr(0x6e)
    print("key_base = {:s}".format(key_base))
    # sys.exit()
    for key_byte in range(0xFF):  # [0-255]
        next_key = key_base + chr(key_byte)
        d = repeating_key_xor(string, next_key)

        # Check bmp magic bz values
        if d[0] == 0x42 and d[1] == 0x4d and d[2] == 0xf6 and d[3] == 0x8f and d[4] == 0x07 and d[5] == 0x00:
            print("key_byte = 0x{:x} ".format(key_byte))
            # write_file("out/ch_{:d}.bmp".format(key_byte), d)   # Write all solutions
            break


def bruteforce(string, possible_substring_in_decoded="flag"):
    keys = []   # Array of possible keys
    key = ""    # Add if you know the first byte (to decode manually checking outputs)
    for byte in range(0xff, 0, -1):    # [255, 0, -1]
        key_to_test = key + chr(byte)
        decrypted = repeating_key_xor(string, key_to_test)

        # print(key_to_test)
        # Try to get decoded xor in ascii (This line not work is expected output are arbitrary bytes)
        try:
            plaint_text = decrypted.decode()
            print("Output = %s | key = 0x%x" % (plaint_text, byte))
            # write_file("possible.keys.txt", plaint_text)   # Open in text editor
            keys.append("".join(key_to_test))
        except UnicodeDecodeError:
            pass

    return keys


if __name__ == "__main__":
    raw = read_file("xor_single.bin")
    d = single_byte_key_xor(raw, 0x41)
    print(d.decode())

    # Xor preserving
    raw = read_file("xor_preserving.bin")
    e = single_preserving_byte_key_xor(raw, 0x42)
    print(list(map(hex, e)))

    # /BinaryCollection/Chapter_13L/Lab13-01.exe
    e = read_file("lab13_xor_data.bin")
    d = single_byte_key_xor(e, 0x3b).decode()
    print(d)













